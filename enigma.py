import sys
import os
import re
import platform
import psutil
from openai import OpenAI
from PyQt5.QtWidgets import (
    QApplication, QMainWindow, QWidget, QVBoxLayout, QHBoxLayout, QLabel, QLineEdit, QPushButton,
    QTextEdit, QFileSystemModel, QTreeView, QSplitter, QComboBox, QSizePolicy, QListWidget, QStackedWidget, QScrollArea
)
from PyQt5.QtCore import Qt, QProcess, QDateTime, QTimer, QThread, pyqtSignal
from PyQt5.QtGui import QFontDatabase, QFont, QPixmap, QIcon

# --- Tab Descriptions for AI Context ---
TAB_DESCRIPTIONS = {
    "Enumeration": (
        "The Enumeration tab helps you discover subdomains for a target domain using tools like Subfinder and Assetfinder. "
        "It merges results, checks which subdomains are alive, and saves all valid subdomains to output/enumeration/<target>."
    ),
    "Information": (
        "The Information tab gathers WHOIS and registration data for a domain. "
        "It helps you understand ownership, registration dates, and contact details."
    ),
    "Crawling": (
        "The Crawling tab discovers hidden paths and endpoints using live crawling (katana) and archive crawling (waybackurls). "
        "It helps you find admin panels, APIs, and old endpoints."
    ),
    "Path Finder": (
        "The Path Finder tab (AdminFinder) identifies sensitive files and directories on a web server, such as admin panels or backups."
    ),
    "SSL/TLS": (
        "The SSL/TLS tab scans SSL/TLS configurations to find weak ciphers, expired certificates, and insecure protocols."
    ),
    "Output Viewer": (
        "The Output Viewer tab lets you browse and review all output files generated by other modules."
    ),
    "Settings": (
        "The Settings tab allows you to change the theme and view system information."
    ),
}

class EnigmaGUI(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("ENIGMA")
        self.setWindowIcon(QIcon("assets/logo.png"))
        self.setFixedSize(1000, 600)
        self.font_family = self.load_regular_font()
        QApplication.setFont(QFont(self.font_family, 12))
    
        self.shared_url = ""
        
        self.logo_label = QLabel()
        self.set_logo("Dark") 
        self.logo_label.setAlignment(Qt.AlignCenter)
        self.logo_label.setStyleSheet("QLabel { margin-bottom: 5px; }")
        
        logo_text = QLabel("Tools List:")
        logo_text.setAlignment(Qt.AlignLeft)

        self.tabs = QListWidget()
        self.tabs.setFixedWidth(150)
        self.tabs.setSpacing(5)
        self.tabs.setStyleSheet("QListWidget::item { margin: 2px; }")
        self.tabs.setSizePolicy(QSizePolicy.Fixed, QSizePolicy.Expanding)

        self.stack = QStackedWidget()

        self.subdomain_tab = SubdomainTab(self)
        self.info_tab = InformationTab(self)
        self.crawl_tab = CrawlingTab(self)
        self.admin_tab = AdminFinderTab(self)
        self.sslscan_tab = SSLScanTab(self)
        self.output_tab = OutputTab()
        self.settings_tab = SettingsTab(self)
        self.ai_assistant_tab = AIAssistantTab(self)

        self.add_tab("Enumeration", self.subdomain_tab)
        self.add_tab("Information", self.info_tab)
        self.add_tab("Crawling", self.crawl_tab)
        self.add_tab("Path Finder", self.admin_tab)
        self.add_tab("SSL/TLS", self.sslscan_tab)
        self.add_tab("Output Viewer", self.output_tab)
        self.add_tab("EnigmAI", self.ai_assistant_tab)
        self.add_tab("Settings", self.settings_tab)


        sidebar_layout = QVBoxLayout()
        sidebar_layout.addWidget(self.logo_label)
        sidebar_layout.addWidget(logo_text)
        sidebar_layout.addWidget(self.tabs)
        sidebar_layout.addStretch()

        main_layout = QHBoxLayout()
        main_layout.addLayout(sidebar_layout)
        main_layout.addWidget(self.stack)

        container = QWidget()
        container.setLayout(main_layout)
        self.setCentralWidget(container)

        self.tabs.currentRowChanged.connect(self.stack.setCurrentIndex)
        self.tabs.setCurrentRow(0)

    def add_tab(self, name, widget):
        self.tabs.addItem(name)
        self.stack.addWidget(widget)

    def load_regular_font(self):
        font_id = QFontDatabase.addApplicationFont("assets/regular.ttf")
        families = QFontDatabase.applicationFontFamilies(font_id)
        if families:
            return families[0]
        return "Sans Serif"

    def get_shared_url(self):
        return self.shared_url

    def set_shared_url(self, url):
        self.shared_url = url
        self.update_tabs_url(url)
        
    def set_logo(self, theme):
        if theme == "Dark":
            pixmap = QPixmap("assets/logo.png")
        else:
            pixmap = QPixmap("assets/logo_black.png")

        pixmap = pixmap.scaledToWidth(120, Qt.SmoothTransformation)
        self.logo_label.setPixmap(pixmap)
        self.logo_label.setAlignment(Qt.AlignCenter)

    def update_tabs_url(self, url):
        for i in range(self.stack.count()):
            widget = self.stack.widget(i)
            if hasattr(widget, "set_url_from_global"):
                widget.set_url_from_global(url)
                
    def apply_theme(self, theme_name):
        self.set_logo(theme_name)

class SubdomainTab(QWidget):
    def __init__(self, parent_gui=None):
        super().__init__()
        self.parent_gui = parent_gui

        layout = QVBoxLayout()
        self.setFont(QApplication.font())

        h_input = QHBoxLayout()
        h_input.addWidget(QLabel("Target URL:"))
        self.url_input = QLineEdit()
        self.url_input.textChanged.connect(self.save_url_to_global)
        h_input.addWidget(self.url_input)
        layout.addLayout(h_input)

        btn_layout = QHBoxLayout()
        self.btn_enum = QPushButton("Enumerate Subdomains")
        self.btn_enum.clicked.connect(self.enumerate_subdomains)
        btn_layout.addWidget(self.btn_enum)

        self.btn_merge = QPushButton("Merge Results")
        self.btn_merge.clicked.connect(self.merge_subdomain_files)
        btn_layout.addWidget(self.btn_merge)

        self.btn_check_alive = QPushButton("Check Alive")
        self.btn_check_alive.clicked.connect(self.check_alive)
        btn_layout.addWidget(self.btn_check_alive)

        layout.addLayout(btn_layout)

        self.console = QTextEdit()
        self.console.setReadOnly(True)
        layout.addWidget(self.console)
        self.setLayout(layout)

        self.console.append("Welcome to the Enumeration Module.\n")
        self.console.append(
            "Enumeration is the first and most critical phase of reconnaissance in any security assessment.\n"
            "In this module, Enigma helps you identify publicly available subdomains belonging to a target domain,\n"
            "using multiple powerful tools like Subfinder and Assetfinder.\n"
        )
        self.console.append(
            "After gathering subdomains, Enigma can check for potentially vulnerable dangling DNS records using\n"
            "Subjack and Subzy, tools commonly used in subdomain takeover detection.\n"
        )
        self.console.append(
            "To streamline your workflow, Enigma automatically merges results from multiple tools\n"
            "and allows you to probe live subdomains with HTTPX to validate which hosts are responsive.\n"
        )
        self.console.append(
            "Usage Tips:\n"
            "- Start with 'Enumerate Target' to run subdomain discovery.\n"
            "- Then click 'Check Alive' to find which subdomains are live and vulnerable.\n"
            "- All outputs are saved under output/enumeration/<target>.\n"
        )

        if self.parent_gui:
            current_url = self.parent_gui.get_shared_url()
            if current_url:
                self.url_input.setText(current_url)

    def save_url_to_global(self):
        if self.parent_gui:
            self.parent_gui.set_shared_url(self.url_input.text().strip())

    def set_url_from_global(self, url):
        self.url_input.setText(url)

    def enumerate_subdomains(self):
        url = self.url_input.text().strip()
        if not url:
            self.console.append("[!] Please enter a target URL.")
            return

        base_path = f'output/enumeration/{url}'
        os.makedirs(base_path, exist_ok=True)

        # Run Subfinder
        subfinder_file = os.path.join(base_path, "subfinder.txt")
        assetfinder_file = os.path.join(base_path, "assetfinder.txt")
        self._execute(f"subfinder -d {url} -o {subfinder_file}")
        self._execute(f"assetfinder --subs-only {url} > {assetfinder_file}")

        self.console.append("[*] Enumeration started. Use 'Merge Results' after tools finish.")

    def merge_subdomain_files(self):
        url = self.url_input.text().strip()
        if not url:
            self.console.append("[!] Please enter a target URL.")
            return

        base_path = f'output/enumeration/{url}'
        subfinder_file = os.path.join(base_path, "subfinder.txt")
        assetfinder_file = os.path.join(base_path, "assetfinder.txt")
        merged_file = os.path.join(base_path, "all_subs.txt")

        all_domains = set()
        for file in [subfinder_file, assetfinder_file]:
            if os.path.exists(file):
                with open(file, 'r') as f:
                    for line in f:
                        line = line.strip()
                        if line.startswith("http://") or line.startswith("https://"):
                            line = re.sub(r'^https?://', '', line)
                            line = line.split('/')[0]
                        if re.match(r'^[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$', line):
                            all_domains.add(line)

        with open(merged_file, 'w') as f:
            for domain in sorted(all_domains):
                f.write(f"{domain}\n")

        self.console.append(f"[+] Merged {len(all_domains)} valid domains into all_subs.txt")

        self.console.append(f"[+] Merged {len(all_domains)} valid domains into all_subs.txt")

    def check_alive(self):
        url = self.url_input.text().strip()
        if not url:
            self.console.append("[!] Please enter a target URL.")
            return

        base_path = f'output/enumeration/{url}'
        infile = os.path.join(base_path, "all_subs.txt")
        outfile = os.path.join(base_path, "alive.txt")

        if not os.path.isfile(infile):
            self.console.append("[!] all_subs.txt not found. Run 'Merge Results' first.")
            return

        cmd = f"cat {infile} | httpx -silent -threads 100 -timeout 5 -no-color -o {outfile}"
        self._execute(cmd)
        self.console.append("[*] Checking alive subdomains. Results will be in alive.txt.")

    def _execute(self, cmd):
        timestamp = QDateTime.currentDateTime().toString("hh:mm:ss")
        self.console.append(f"[{timestamp}] Running: {cmd}")
        proc = QProcess(self)
        env = proc.processEnvironment()
        env.insert("PATH", os.environ.get("PATH", ""))
        env.insert("HOME", os.environ.get("HOME", os.path.expanduser("~")))
        proc.setProcessEnvironment(env)
        proc.setProcessChannelMode(QProcess.MergedChannels)

        # Only print lines that look like domains or URLs
        def handle_output():
            data = proc.readAllStandardOutput().data().decode()
            if data:
                for line in data.splitlines():
                    line = line.strip()
                    # Only show lines that look like domains or URLs
                    if re.match(r'^(https?://)?[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$', line):
                        self.console.append(line)

        proc.readyReadStandardOutput.connect(handle_output)
        proc.finished.connect(lambda code, status: None)
        proc.start("/bin/bash", ["-lc", cmd])

class InformationTab(QWidget):
    def __init__(self, parent_gui=None):
        super().__init__()
        self.parent_gui = parent_gui

        layout = QVBoxLayout()
        self.setFont(QApplication.font())

        h_input = QHBoxLayout()
        h_input.addWidget(QLabel("Target URL:"))
        self.input_url = QLineEdit()
        self.input_url.textChanged.connect(self.save_url_to_global)
        h_input.addWidget(self.input_url)
        layout.addLayout(h_input)

        self.btn_whois = QPushButton("Collect Information")
        self.btn_whois.clicked.connect(self.run_whois)
        layout.addWidget(self.btn_whois)

        self.console = QTextEdit()
        self.console.setReadOnly(True)
        layout.addWidget(self.console)

        self.setLayout(layout)
        
        self.console.append("Welcome to the Information Module.\n")
        self.console.append(
            "This tab is designed to help you gather essential domain registration\n"
            "and ownership data using WHOIS lookups. It is a critical step in passive\n"
            "reconnaissance, allowing you to retrieve registrar information, creation and\n"
            "expiration dates, name servers, and contact details if available.\n"
        )
        self.console.append(
            "Knowing who owns a domain and when it was registered can help identify\n"
            "potential targets, expired domains, or interesting patterns in the organization's\n"
            "domain infrastructure.\n"
        )
        self.console.append(
            "Usage Tips:\n"
            "- Enter a domain to run a WHOIS query.\n"
            "- Results will be printed here and saved to output/information/<domain>.txt\n"
        )
        if self.parent_gui:
            current_url = self.parent_gui.get_shared_url()
            if current_url:
                self.input_url.setText(current_url)

    def save_url_to_global(self):
        if self.parent_gui:
            self.parent_gui.set_shared_url(self.input_url.text().strip())

    def set_url_from_global(self, url):
        cursor_pos = self.input_url.cursorPosition()
        self.input_url.blockSignals(True)
        self.input_url.setText(url)
        self.input_url.setCursorPosition(min(cursor_pos, len(url)))
        self.input_url.blockSignals(False)

    def run_whois(self):
        url = self.input_url.text().strip()
        if not url:
            self.console.append("[!] Please enter a domain or URL.")
            return
        os.makedirs(f"output/information/{url}", exist_ok=True)
        self.output_file = f"output/information/{url}/information.txt"
        cmd = f"whois {url}"
        self._execute(cmd)

    def _execute(self, cmd):
        timestamp = QDateTime.currentDateTime().toString("hh:mm:ss")
        self.console.append(
            f"[{timestamp}] Collecting target information\n"
            f"[{timestamp}] Please wait until the process is finished.\n"
        )

        self.output_lines = []

        self.proc = QProcess(self)
        env = self.proc.processEnvironment()
        env.insert("PATH", os.environ.get("PATH", ""))
        env.insert("HOME", os.environ.get("HOME", os.path.expanduser("~")))
        self.proc.setProcessEnvironment(env)
        self.proc.setProcessChannelMode(QProcess.MergedChannels)

        def handle_output():
            data = self.proc.readAllStandardOutput().data().decode(errors='ignore')
            if data:
                self.console.moveCursor(self.console.textCursor().End)
                self.console.insertPlainText(data)
                self.output_lines.append(data)

        def save_output():
            try:
                with open(self.output_file, 'w', encoding='utf-8') as f:
                    f.writelines(self.output_lines)
            except Exception as e:
                self.console.append(f"[!] Failed to save output: {e}")

        self.proc.readyReadStandardOutput.connect(handle_output)
        self.proc.finished.connect(save_output)
        self.proc.start("/bin/bash", ["-lc", cmd])



class CrawlingTab(QWidget):
    def __init__(self, parent_gui=None):
        super().__init__()
        self.parent_gui = parent_gui

        layout = QVBoxLayout()
        self.setFont(QApplication.font())

        h_input = QHBoxLayout()
        h_input.addWidget(QLabel("Target URL:"))
        self.input_url = QLineEdit()
        self.input_url.textChanged.connect(self.save_url_to_global)
        h_input.addWidget(self.input_url)
        layout.addLayout(h_input)

        btn_layout = QHBoxLayout()
        self.btn_live = QPushButton("Live Crawling")
        self.btn_live.clicked.connect(self.run_katana)
        btn_layout.addWidget(self.btn_live)

        self.btn_archive = QPushButton("Archive Crawling")
        self.btn_archive.clicked.connect(self.run_waybackurls)
        btn_layout.addWidget(self.btn_archive)

        layout.addLayout(btn_layout)

        self.console = QTextEdit()
        self.console.setReadOnly(True)
        layout.addWidget(self.console)

        self.setLayout(layout)

        self.console.append("Welcome to the Crawling Module.\n")
        self.console.append(
            "This module allows you to discover hidden paths, parameters, endpoints,\n"
            "and archived content from both live and historical sources.\n"
        )
        self.console.append(
            "Live crawling uses 'katana' to scan reachable URLs and endpoints in real-time,\n"
            "while archive crawling leverages 'waybackurls' to gather URLs from the Internet Archive.\n"
        )
        self.console.append(
            "These methods help uncover admin panels, hidden directories, old APIs, or endpoints\n"
            "that are no longer linked but still accessible.\n"
        )
        self.console.append(
            "Usage Tips:\n"
            "- Use Live Crawling to find active endpoints.\n"
            "- Use Archive Crawling to find historical URLs of the domain.\n"
            "- Outputs are saved in output/crawling/<domain>/\n"
        )

        if self.parent_gui:
            current_url = self.parent_gui.get_shared_url()
            if current_url:
                self.input_url.setText(current_url)

    def save_url_to_global(self):
        if self.parent_gui:
            self.parent_gui.set_shared_url(self.input_url.text().strip())

    def set_url_from_global(self, url):
        cursor_pos = self.input_url.cursorPosition()
        self.input_url.blockSignals(True)
        self.input_url.setText(url)
        self.input_url.setCursorPosition(min(cursor_pos, len(url)))
        self.input_url.blockSignals(False)

    def run_katana(self):
        url = self.input_url.text().strip()
        if not url:
            self.console.append("[!] Please enter a target URL or domain.")
            return
        os.makedirs(f"output/crawling/{url}/", exist_ok=True)
        outfile = f"output/crawling/{url}/live_crawling.txt"
        cmd = f"echo {url} | katana | tee {outfile}"
        self._execute(cmd)

    def run_waybackurls(self):
        url = self.input_url.text().strip()
        if not url:
            self.console.append("[!] Please enter a target URL or domain.")
            return
        os.makedirs(f"output/crawling/{url}/", exist_ok=True)
        outfile = f"output/crawling/{url}/archive_crawling.txt"
        cmd = f"echo {url} | waybackurls | tee {outfile}"
        self._execute(cmd)

    def _execute(self, cmd):
        timestamp = QDateTime.currentDateTime().toString("hh:mm:ss")
        self.console.append(
            f"[{timestamp}] Crawling the target\n"
            f"[{timestamp}] Please wait until the process is finished.\n"
        )

        self.proc = QProcess(self)
        env = self.proc.processEnvironment()
        env.insert("PATH", os.environ.get("PATH", ""))
        env.insert("HOME", os.environ.get("HOME", os.path.expanduser("~")))
        self.proc.setProcessEnvironment(env)
        self.proc.setProcessChannelMode(QProcess.SeparateChannels)

        def handle_stdout():
            data = self.proc.readAllStandardOutput().data().decode()
            filtered = self._filter_urls_only(data)
            if filtered:
                self.console.append(filtered)

        def handle_stderr():
            data = self.proc.readAllStandardError().data().decode()
            lines = data.strip().split('\n')
            ansi_escape = re.compile(r'\x1B\[[0-?]*[ -/]*[@-~]')
            for line in lines:
                clean_line = ansi_escape.sub('', line).strip()
                if not clean_line:
                    continue
                if (
                    'projectdiscovery.io' in clean_line
                    or 'katana version' in clean_line.lower()
                    or 'started' in clean_line.lower()
                    or clean_line.startswith('[')
                    or re.match(r'^[\W_]+$', clean_line)
                ):
                    continue
                self.console.append(f"[stderr] {clean_line}")

        self.proc.readyReadStandardOutput.connect(handle_stdout)
        self.proc.readyReadStandardError.connect(handle_stderr)
        self.proc.start("/bin/bash", ["-lc", cmd])

    def _filter_urls_only(self, text):
        lines = text.strip().split('\n')
        url_pattern = re.compile(r'^https?://[^\s]+$')
        ascii_pattern = re.compile(r'[\u2500-\u25FF\u2580-\u259F\u2600-\u26FF\u2700-\u27BF]')
        return '\n'.join(
            line.strip() for line in lines
            if url_pattern.match(line.strip())
            and 'projectdiscovery.io' not in line
            and not ascii_pattern.search(line)
        ) or ''

class AdminFinderTab(QWidget):
    def __init__(self, parent_gui=None):
        super().__init__()
        self.parent_gui = parent_gui

        layout = QVBoxLayout()
        self.setFont(QApplication.font())

        input_layout = QHBoxLayout()
        input_layout.addWidget(QLabel("Target URL:"))
        self.input_url = QLineEdit()
        self.input_url.textChanged.connect(self.save_url_to_global)
        input_layout.addWidget(self.input_url)
        layout.addLayout(input_layout)

        self.btn_run = QPushButton("Find Sensitive Paths")
        self.btn_run.clicked.connect(self.run_admin_finder)
        layout.addWidget(self.btn_run)

        self.console = QTextEdit()
        self.console.setReadOnly(True)
        layout.addWidget(self.console)

        self.setLayout(layout)

        self.console.append("Welcome to the Path Finder Module.\n")
        self.console.append(
            "This module helps you identify accessible files, folders, and potential hidden\n"
            "resources within a web server. It uses techniques such as directory brute-forcing\n"
            "to uncover admin panels, configuration files, backups, and other sensitive paths.\n"
        )
        self.console.append(
            "Discovering these hidden endpoints can often lead to privilege escalation,\n"
            "information leakage, or even direct exploitation vectors.\n"
        )
        self.console.append(
            "Usage Tips:\n"
            "- Enter a target domain or URL (e.g., https://target.com)\n"
            "- Output will be saved under output/pathfinder/<target>.\n"
        )

        if self.parent_gui:
            current_url = self.parent_gui.get_shared_url()
            if current_url:
                self.input_url.setText(current_url)

    def save_url_to_global(self):
        if self.parent_gui:
            self.parent_gui.set_shared_url(self.input_url.text().strip())

    def set_url_from_global(self, url):
        cursor_pos = self.input_url.cursorPosition()
        self.input_url.blockSignals(True)
        self.input_url.setText(url)
        self.input_url.setCursorPosition(min(cursor_pos, len(url)))
        self.input_url.blockSignals(False)


    def run_admin_finder(self):
        url = self.input_url.text().strip()
        if not url:
            self.console.append("[!] Please enter a target URL.")
            return

        os.makedirs(f"output/pathfinder/{url}", exist_ok=True)
        self.output_file = f"output/pathfinder/{url}/paths.txt"
        cmd = f"okadminfinder -u https://{url}"
        self._execute(cmd)

    def _execute(self, cmd):
        timestamp = QDateTime.currentDateTime().toString("hh:mm:ss")
        self.console.append(
            f"[{timestamp}] Enumerating sensitive paths\n"
            f"[{timestamp}] Please wait until the process is finished.\n"
        )

        self.proc = QProcess(self)
        env = self.proc.processEnvironment()
        env.insert("PATH", os.environ.get("PATH", ""))
        env.insert("HOME", os.environ.get("HOME", os.path.expanduser("~")))
        self.proc.setProcessEnvironment(env)
        self.proc.setProcessChannelMode(QProcess.MergedChannels)

        self.output_lines = []

        def handle_output():
            raw_data = self.proc.readAllStandardOutput().data().decode(errors='ignore')
            self.output_lines.append(raw_data)

            with open(self.output_file, 'a', encoding='utf-8') as f:
                f.write(raw_data)

            filtered = self._extract_urls_from_ascii_output(raw_data)
            if filtered:
                self.console.append(filtered)

        self.proc.readyReadStandardOutput.connect(handle_output)
        self.proc.start("/bin/bash", ["-lc", cmd])

    def _extract_urls_from_ascii_output(self, text):
        url_pattern = re.compile(r'https?://[a-zA-Z0-9./\-_]+')
        urls = url_pattern.findall(text)
        return '\n'.join(sorted(set(urls)))
            
class SSLScanTab(QWidget):
    def __init__(self, parent_gui=None):
        super().__init__()
        self.parent_gui = parent_gui

        layout = QVBoxLayout()
        self.setFont(QApplication.font())

        input_layout = QHBoxLayout()
        input_layout.addWidget(QLabel("Target URL:"))
        self.input_url = QLineEdit()
        self.input_url.textChanged.connect(self.save_url_to_global)
        input_layout.addWidget(self.input_url)
        layout.addLayout(input_layout)

        self.btn_run = QPushButton("Run SSLScan")
        self.btn_run.clicked.connect(self.run_sslscan)
        layout.addWidget(self.btn_run)

        self.console = QTextEdit()
        self.console.setReadOnly(True)
        layout.addWidget(self.console)

        self.setLayout(layout)

        self.console.append("Welcome to the SSL/TLS Scanner Module.\n")
        self.console.append(
            "This module scans SSL/TLS configurations of a given host using sslscan.\n"
            "It helps identify insecure protocols, weak ciphers, expired certificates,\n"
            "and other misconfigurations that could compromise secure communications.\n"
        )
        self.console.append(
            "Understanding SSL/TLS posture is critical in securing modern web applications,\n"
            "especially for domains handling sensitive user data or financial transactions.\n"
        )
        self.console.append(
            "Usage Tips:\n"
            "- Input a domain or IP with HTTPS enabled (e.g., tesla.com).\n"
            "- Output is saved to output/ssl/<domain>.txt for future reference.\n"
        )

        if self.parent_gui:
            current_url = self.parent_gui.get_shared_url()
            if current_url:
                self.input_url.setText(current_url)

    def save_url_to_global(self):
        if self.parent_gui:
            self.parent_gui.set_shared_url(self.input_url.text().strip())

    def set_url_from_global(self, url):
        cursor_pos = self.input_url.cursorPosition()
        self.input_url.blockSignals(True)
        self.input_url.setText(url)
        self.input_url.setCursorPosition(min(cursor_pos, len(url)))
        self.input_url.blockSignals(False)


    def run_sslscan(self):
        url = self.input_url.text().strip()
        if not url:
            self.console.append("[!] Please enter a target URL or domain.")
            return

        os.makedirs(f"output/sslscan/{url}", exist_ok=True)
        self.output_file = f"output/sslscan/{url}/sslscan.txt"
        cmd = f"sslscan --no-colour {url}"
        self._execute(cmd)

    def _execute(self, cmd):
        timestamp = QDateTime.currentDateTime().toString("hh:mm:ss")
        self.console.append(f"[{timestamp}] Running SSLScan\n[{timestamp}] Please wait until the process is finished.\n")

        self.proc = QProcess(self)
        env = self.proc.processEnvironment()
        env.insert("PATH", os.environ.get("PATH", ""))
        env.insert("HOME", os.environ.get("HOME", os.path.expanduser("~")))
        self.proc.setProcessEnvironment(env)
        self.proc.setProcessChannelMode(QProcess.MergedChannels)

        self.output_lines = []

        self.proc.readyReadStandardOutput.connect(self.handle_stdout)
        self.proc.readyReadStandardError.connect(self.handle_stderr)
        self.proc.finished.connect(self.save_output)
        self.proc.start("/bin/bash", ["-lc", cmd])

    def handle_stdout(self):
        data = self.proc.readAllStandardOutput().data().decode(errors='ignore')
        self.console.moveCursor(self.console.textCursor().End)
        self.console.insertPlainText(data)
        self.output_lines.append(data)

    def handle_stderr(self):
        data = self.proc.readAllStandardError().data().decode(errors='ignore')
        self.console.moveCursor(self.console.textCursor().End)
        self.console.insertPlainText(data)
        self.output_lines.append(data)

    def save_output(self):
        with open(self.output_file, 'w', encoding='utf-8') as f:
            f.writelines(self.output_lines)


class OutputTab(QWidget):
    def __init__(self):
        super().__init__()
        self.setFont(QApplication.font())

        layout = QVBoxLayout()

        self.viewer = QTextEdit()
        self.viewer.setReadOnly(True)
        self.viewer.setPlainText(
            "Welcome to the Output Viewer Module.\n\n"
            "This module allows you to quickly browse and review output files generated\n"
            "by other modules in Enigma. All scans and tools store their results under\n"
            "the organized output/ directory structure.\n\n"
            "Usage Tips:\n"
            "- Use the list on the left to open a scan result.\n"
            "- Output is grouped by module and target domain.\n"
            "- Non-URL results (like whois or sslscan) will be shown in full.\n"
        )

        self.file_list = QTreeView()
        self.model = QFileSystemModel()
        self.model.setRootPath(os.path.abspath('output'))
        self.model.setNameFilters(["*.txt"])
        self.model.setNameFilterDisables(False)

        self.file_list.setModel(self.model)
        self.file_list.setRootIndex(self.model.index(os.path.abspath('output')))
        self.file_list.setHeaderHidden(True)
        self.file_list.setColumnHidden(1, True)
        self.file_list.setColumnHidden(2, True)
        self.file_list.setColumnHidden(3, True)
        self.file_list.clicked.connect(self.on_file_clicked)

        splitter = QSplitter(Qt.Horizontal)
        splitter.addWidget(self.file_list)
        splitter.addWidget(self.viewer)
        splitter.setSizes([300, 600])
        layout.addWidget(splitter)

        self.setLayout(layout)

    def on_file_clicked(self, index):
        path = self.model.filePath(index)

        if os.path.isdir(path):
            self.viewer.clear()
            return

        if os.path.isfile(path):
            try:
                with open(path, 'r', encoding='utf-8', errors='ignore') as f:
                    content = f.read()
                    filename = os.path.basename(path).lower()

                    if "information" in filename or "sslscan" in filename:
                        self.viewer.setPlainText(content)
                    else:
                        filtered_content = self._filter_urls_only(content)
                        self.viewer.setPlainText(filtered_content)
            except Exception as e:
                self.viewer.setPlainText(f"Cannot open file: {e}")

    def _filter_urls_only(self, text):
        lines = text.strip().split('\n')
        url_pattern = re.compile(r'^(https?://[^\s]+|[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})$')
        return '\n'.join(
            line.strip() for line in lines
            if url_pattern.match(line.strip()) and 'projectdiscovery.io' not in line
        ) or 'No URLs found in this file'
from PyQt5.QtGui import QPainter


class MarqueeLabel(QLabel):
    def __init__(self, text="", parent=None):
        super().__init__(parent)
        self.original_text = text
        self.setStyleSheet("color: gray; font-size: 17px;")
        self.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Fixed)
        self.setMinimumHeight(20)

        self.offset = 0
        self.scroll_speed = 1
        self.timer = QTimer(self)
        self.timer.timeout.connect(self.update_offset)
        self.timer.start(30) 

    def update_offset(self):
        self.offset += self.scroll_speed
        text_width = self.fontMetrics().width(self.original_text)
        if self.offset > text_width:
            self.offset = 0
        self.update()

    def paintEvent(self, event):
        painter = QPainter(self)
        painter.setFont(self.font())
        fm = self.fontMetrics()
        text_width = fm.width(self.original_text)
        height = int(self.height() * 0.75)

        x1 = -self.offset
        x2 = x1 + text_width

        painter.drawText(x1, height, self.original_text)
        painter.drawText(x2, height, self.original_text)

class OpenAIWorker(QThread):
    result = pyqtSignal(str)

    def __init__(self, client, system_prompt, user_input):
        super().__init__()
        self.client = client
        self.system_prompt = system_prompt
        self.user_input = user_input

    def run(self):
        try:
            response = self.client.responses.create(
                model="gpt-4o-mini",
                input=f"{self.system_prompt}\nUser: {self.user_input}",
                store=True,
            )
            ai_reply = response.output_text.strip()
        except Exception as e:
            ai_reply = f"[Exception] {e}"
        self.result.emit(ai_reply)

class AIAssistantTab(QWidget):
    API_KEY_FILE = "openai_apikey.txt"

    def __init__(self, parent_gui=None):
        super().__init__()
        self.parent_gui = parent_gui
        self.setObjectName("AIAssistantTab")

        self.api_key = None
        self.openai_client = None

        # Try to load API key from file
        if os.path.exists(self.API_KEY_FILE):
            with open(self.API_KEY_FILE, "r") as f:
                key = f.read().strip()
                if key:
                    self.api_key = key
                    self.openai_client = OpenAI(api_key=self.api_key)

        main_layout = QVBoxLayout(self)
        main_layout.setSpacing(8)
        main_layout.setContentsMargins(10, 10, 10, 10)

        self.chat_area = QVBoxLayout()
        self.chat_area.setAlignment(Qt.AlignTop)

        chat_widget = QWidget()
        chat_widget.setLayout(self.chat_area)

        self.scroll = QScrollArea()
        self.scroll.setWidgetResizable(True)
        self.scroll.setWidget(chat_widget)
        main_layout.addWidget(self.scroll, stretch=1)

        input_layout = QHBoxLayout()
        self.input_box = QLineEdit()
        self.input_box.setPlaceholderText("Type your message...")
        self.input_box.setObjectName("AIAssistantInput")
        self.input_box.returnPressed.connect(self.send_query)
        input_layout.addWidget(self.input_box)

        self.send_btn = QPushButton("Send")
        self.send_btn.setObjectName("AIAssistantSend")
        self.send_btn.clicked.connect(self.send_query)
        input_layout.addWidget(self.send_btn)

        main_layout.addLayout(input_layout)

        # Show welcome or API key prompt
        if self.api_key:
            self.add_message(
                "Welcome to <b>EnigmAI</b>!<br>"
                "EnigmAI is your specialized AI assistant for bug bounty, red teaming, and hacking.<br>"
                "Ask anything about recon, exploitation, tools, or security techniques.",
                sender="ai"
            )
        else:
            self.add_message(
                "<b>Welcome to EnigmAI!</b><br>"
                "To use the AI assistant, please set your OpenAI API key first.<br>"
                "Get your API key at: https://platform.openai.com/api-keys</a><br>"
                "Type: <code>set api_key=\"your-openai-apikey\"</code> in the chat below.",
                sender="ai"
            )

    def clear_ai_messages(self):
        # Remove all AI messages from chat_area
        for i in reversed(range(self.chat_area.count())):
            item = self.chat_area.itemAt(i)
            widget = item.widget()
            if isinstance(widget, QLabel) and widget.property("chatbubble") == "ai":
                widget.deleteLater()
                self.chat_area.removeItem(item)

    def add_message(self, text, sender="user"):
        import re
        bubble = QLabel()
        bubble.setWordWrap(True)
        bubble.setTextFormat(Qt.RichText)
        bubble.setTextInteractionFlags(Qt.TextSelectableByMouse)
        if sender == "ai":
            # Headings
            text = re.sub(r"^#### (.+)$", r"<h4>\1</h4>", text, flags=re.MULTILINE)
            text = re.sub(r"^### (.+)$", r"<h3>\1</h3>", text, flags=re.MULTILINE)
            text = re.sub(r"^## (.+)$", r"<h2>\1</h2>", text, flags=re.MULTILINE)
            text = re.sub(r"^# (.+)$", r"<h1>\1</h1>", text, flags=re.MULTILINE)
            # Horizontal line
            text = re.sub(r"^---$", r"<hr style='color:white;'>", text, flags=re.MULTILINE)
            # Bold
            text = re.sub(r"\*\*(.+?)\*\*", r"<b>\1</b>", text)
            # List
            lines = text.split('\n')
            html_lines = []
            in_ul = False
            for line in lines:
                if re.match(r"^\s*-\s+", line):
                    if not in_ul:
                        html_lines.append("<ul style='margin-top:0;margin-bottom:0;padding-left:18px;'>")
                        in_ul = True
                    html_lines.append(f"<li>{line.strip()[2:]}</li>")
                else:
                    if in_ul:
                        html_lines.append("</ul>")
                        in_ul = False
                    # Spacer for empty line
                    if line.strip() == "":
                        html_lines.append("<div style='height:12px'></div>")
                    else:
                        html_lines.append(line)
            if in_ul:
                html_lines.append("</ul>")
            text = "\n".join(html_lines)
            # Wrap with line-height for better readability
            text = f"<div style='line-height:1.3'>{text}</div>"
        else:
            # Wrap user bubble with line-height 1.3
            text = f"<div style='line-height:1.3'>{text}</div>"
        bubble.setText(text)
        bubble.setProperty("chatbubble", sender)
        bubble.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Preferred)
        bubble.setAlignment(Qt.AlignRight if sender == "user" else Qt.AlignLeft)
        self.chat_area.addWidget(bubble)
        self.chat_area.addSpacing(2)
        QTimer.singleShot(100, lambda: self.scroll.verticalScrollBar().setValue(self.scroll.verticalScrollBar().maximum()))

    def send_query(self):
        user_input = self.input_box.text().strip()
        if not user_input:
            return
        # Check for API key command
        if user_input.lower().startswith("set api_key="):
            import re
            match = re.match(r'set api_key\s*=\s*["\']?([a-zA-Z0-9\-_\.]+)["\']?', user_input, re.IGNORECASE)
            if match:
                self.api_key = match.group(1)
                self.openai_client = OpenAI(api_key=self.api_key)
                # Save API key to file
                with open(self.API_KEY_FILE, "w") as f:
                    f.write(self.api_key)
                self.input_box.clear()
                # Clear all previous chat (user and AI)
                for i in reversed(range(self.chat_area.count())):
                    item = self.chat_area.itemAt(i)
                    widget = item.widget()
                    if widget is not None:
                        widget.deleteLater()
                    self.chat_area.removeItem(item)
                self.add_message(
                    "Welcome to <b>EnigmAI</b>!<br>"
                    "EnigmAI is your specialized AI assistant for bug bounty, red teaming, and hacking.<br>"
                    "Ask anything about recon, exploitation, tools, or security techniques.",
                    sender="ai"
                )
            else:
                self.add_message(user_input, sender="user")
                self.input_box.clear()
                self.add_message(
                    "Invalid API key format. Please use: <code>set api_key=\"your-openai-apikey\"</code>",
                    sender="ai"
                )
            return

        self.add_message(user_input, sender="user")
        self.input_box.clear()

        # If API key not set, block AI
        if not self.openai_client:
            self.add_message(
                "Please set your OpenAI API key first using:<br>"
                "<code>set api_key=\"your-openai-apikey\"</code><br>"
                "Get your API key at: <a href='https://platform.openai.com/api-keys'>https://platform.openai.com/api-keys</a>",
                sender="ai"
            )
            return

        self.add_message("EnigmAI is thinking...", sender="ai")
        QTimer.singleShot(100, lambda: self.ask_openai(user_input))

    def ask_openai(self, user_input):
        # Add context about tabs if user asks about them
        context = ""
        for tab, desc in TAB_DESCRIPTIONS.items():
            if tab.lower() in user_input.lower():
                context += f"\n\nAbout the '{tab}' tab: {desc}"
        system_prompt = (
            "You are EnigmAI, an expert AI assistant for bug hunters, red teamers, and hackers. "
            "You provide concise, actionable, and technically accurate answers about security, "
            "reconnaissance, exploitation, and hacking tools. Always be practical and direct."
            "your answers are neatly structured, not just plaintext"
            "You are an AI assistant for ENIGMA, ENIGMA is a red teaming tool, this tool contains tabs or special tools for bug hunters, if the user asks for a guide for ENIGMA, focus on the list of tabs or tools available"
            "Your developer is KiddTheReaper, you are a tools, ai assistant in tool for bug hunters, red teamers and hackers named ENIGMA."
            """Tabs available in ENIGMA are:
            Enumeration:
                The Enumeration tab helps you discover subdomains for a target domain using tools like Subfinder and Assetfinder. 
                It merges results, checks which subdomains are alive, and saves all valid subdomains to output/enumeration/<target>.
            Information:
                The Information tab gathers WHOIS and registration data for a domain. 
                It helps you understand ownership, registration dates, and contact details.
            Crawling: 
                The Crawling tab discovers hidden paths and endpoints using live crawling (katana) and archive crawling (waybackurls). 
                It helps you find admin panels, APIs, and old endpoints.
            Path Finder:
                The Path Finder tab identifies sensitive files and directories on a web server, such as admin panels or backups.
            SSL/TLS: 
                The SSL/TLS tab scans SSL/TLS configurations to find weak ciphers, expired certificates, and insecure protocols.
            Output Viewer:
                The Output Viewer tab lets you browse and review all output files generated by other modules.
            Settings:
                The Settings tab allows you to change the theme and view system information."""
            + context
        )
        # Use a worker thread for OpenAI call
        self.worker = OpenAIWorker(self.openai_client, system_prompt, user_input)
        self.worker.result.connect(self.handle_ai_reply)
        self.worker.start()

    def handle_ai_reply(self, ai_reply):
        # Remove the "EnigmAI is thinking..." bubble (even if spacers are present)
        for i in range(self.chat_area.count() - 1, -1, -1):
            item = self.chat_area.itemAt(i)
            widget = item.widget()
            if isinstance(widget, QLabel) and "EnigmAI is thinking" in widget.text():
                widget.deleteLater()
                self.chat_area.removeItem(item)
                break
        self.add_message(ai_reply, sender="ai")

# --- Settings Tab (no marquee/thanks) ---
class SettingsTab(QWidget):
    def __init__(self, parent_gui=None):
        super().__init__()
        self.parent_gui = parent_gui

        layout = QVBoxLayout()

        layout.addWidget(QLabel("Theme:"))
        self.theme_selector = QComboBox()
        self.theme_selector.addItems(["Dark", "Light"])
        self.theme_selector.currentTextChanged.connect(self.change_theme)
        layout.addWidget(self.theme_selector)

        layout.addWidget(QLabel("System Information:"))
        self.sysinfo = QTextEdit()
        self.sysinfo.setReadOnly(True)
        self.sysinfo.setMaximumHeight(165) 
        layout.addWidget(self.sysinfo)

        layout.addWidget(QLabel("Real-time Usage:"))
        self.usage_info = QTextEdit()
        self.usage_info.setReadOnly(True)
        self.usage_info.setMaximumHeight(65) 
        layout.addWidget(self.usage_info)

        layout.addWidget(QLabel("Information:"))
        self.app_info = QTextEdit()
        self.app_info.setReadOnly(True)
        self.app_info.setText(self.get_app_info())
        layout.addWidget(self.app_info)
        self.app_info.setMaximumHeight(190) 

        self.setLayout(layout)

        self.load_static_info()

        self.timer = QTimer()
        self.timer.timeout.connect(self.update_usage_info)
        self.timer.start(2000) 

    def change_theme(self, theme_name):
        path = f"theme/{theme_name.lower()}.css"
        try:
            with open(path, 'r') as f:
                stylesheet = f.read()
                QApplication.instance().setStyleSheet(stylesheet)
        except FileNotFoundError:
            print(f"[!] Theme file '{path}' not found. Using default.")
            QApplication.instance().setStyleSheet("")

        if hasattr(self.parent_gui, 'set_logo'):
            self.parent_gui.set_logo(theme_name)

    def load_static_info(self):
        info = []
        info.append(f"OS: {platform.system()} {platform.release()}")
        info.append(f"Architecture: {platform.machine()}")
        info.append(f"CPU Cores: {psutil.cpu_count(logical=True)}")
        info.append(f"Total RAM: {round(psutil.virtual_memory().total / (1024 ** 3), 2)} GB")
        info.append(f"Hostname: {platform.node()}")
        info.append(f"Kernel: {platform.version()}")
        self.sysinfo.setText("\n".join(info))

    def update_usage_info(self):
        cpu = psutil.cpu_percent(interval=0.5)
        ram = psutil.virtual_memory()
        used_ram = round(ram.used / (1024 ** 3), 2)
        total_ram = round(ram.total / (1024 ** 3), 2)
        usage_text = f"CPU Usage: {cpu}%\nRAM Usage: {used_ram} GB / {total_ram} GB"
        self.usage_info.setText(usage_text)

    def get_app_info(self):
        info = []
        info.append("Developed by @KiddTheReaper")
        info.append("Version: 1.0")
        info.append("Telegram: @KiddTheReaper")
        info.append("TikTok: @justan0therloser")
        info.append("Note: Use this tool at your own risk. The developer is not responsible for any illegal activities.")
        return "\n".join(info)

if __name__ == '__main__':
    app = QApplication(sys.argv)

    font_db = QFontDatabase()
    font_id = font_db.addApplicationFont("assets/regular.ttf")
    families = font_db.applicationFontFamilies(font_id)

    if families:
        font_family = families[0]
    else:
        font_family = "Sans Serif" 
    
    window = EnigmaGUI()
    window.settings_tab.change_theme("Dark")
    window.show()
    sys.exit(app.exec_())